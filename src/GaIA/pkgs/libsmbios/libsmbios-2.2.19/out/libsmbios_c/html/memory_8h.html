<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libsmbios_c library: memory.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>/san/data/shared/software/internal/UNItools/src/GaIA/pkgs/libsmbios/libsmbios-2.2.19/src/include/smbios_c/memory.h File Reference</h1><code>#include "<a class="el" href="compat_8h-source.html">smbios_c/compat.h</a>"</code><br>
<code>#include "<a class="el" href="types_8h-source.html">smbios_c/types.h</a>"</code><br>

<p>
<a href="memory_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int DLL_SPEC&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="memory_8h.html#a0">memory_read</a> (void *buffer, u64 offset, size_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read byte range from physical memory address.  <a href="#a0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int DLL_SPEC&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="memory_8h.html#a1">memory_write</a> (void *buffer, u64 offset, size_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a buffer to a physical memory address.  <a href="#a1"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>s64 DLL_SPEC&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="memory_8h.html#a2">memory_search</a> (const char *pat, size_t patlen, u64 start, u64 end, u64 stride)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search a range of physical addresses for a pattern.  <a href="#a2"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void DLL_SPEC&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="memory_8h.html#a3">memory_suggest_leave_open</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimize memory device access - request memory device be kept open between calls.  <a href="#a3"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void DLL_SPEC&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="memory_8h.html#a4">memory_suggest_close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimize memory device access - request memory device be closed between calls.  <a href="#a4"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const char *DLL_SPEC&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="memory_8h.html#a5">memory_strerror</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns string describing the last error condition.  <a href="#a5"></a><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a0" doxytag="memory.h::memory_read" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int DLL_SPEC memory_read </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u64&nbsp;</td>
          <td class="mdname" nowrap> <em>offset</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read byte range from physical memory address. 
<p>
This function will read a range of bytes from a physical memory address. Note that some OS have severe restrictions on which addresses may be read and written, as well as security restrictions on which security levels are allowed this access. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>buffer</em>&nbsp;</td><td>pointer to buffer were memory will be copied </td></tr>
    <tr><td valign=top><em>offset</em>&nbsp;</td><td>starting memory offset </td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>how many bytes of memory to copy </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, &lt; 0 on failure -1 general failure -5 bad memory_access_object (could not instantiate singleton?) -6 bad buffer pointer </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="memory.h::memory_search" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> s64 DLL_SPEC memory_search </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pat</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>patlen</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u64&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u64&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u64&nbsp;</td>
          <td class="mdname" nowrap> <em>stride</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Search a range of physical addresses for a pattern. 
<p>
Note that some OS have severe restrictions on which addresses may be read and written, as well as security restrictions on which security levels are allowed this access. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pat</em>&nbsp;</td><td>buffer containing byte pattern to search for </td></tr>
    <tr><td valign=top><em>patlen</em>&nbsp;</td><td>length of pattern </td></tr>
    <tr><td valign=top><em>start</em>&nbsp;</td><td>physical address offset to start search </td></tr>
    <tr><td valign=top><em>end</em>&nbsp;</td><td>ending physical address offset </td></tr>
    <tr><td valign=top><em>stride</em>&nbsp;</td><td>search for pattern only where physical addresses  stride == 0 </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>-1 on failure. offset of memory address where pattern found on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="memory.h::memory_strerror" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* DLL_SPEC memory_strerror </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns string describing the last error condition. 
<p>
Can return 0. The buffer used is guaranteed to be valid until the next call to any memory_* function. Copy the contents if you need it longer.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="memory.h::memory_suggest_close" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void DLL_SPEC memory_suggest_close </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimize memory device access - request memory device be closed between calls. 
<p>
By default, the memory device is closed between subsequent calls to read/write. This is to prevent file descriptor leakage by the libsmbios library. At times, however, the overhead of reopening the memory device file on every access is simply too great. This happens, for example, on memory searches, and can add considerable overhead. This function cancels a previous request to leave the device open between calls. Must be properly nested with <a class="el" href="memory_8h.html#a3">memory_suggest_leave_open()</a>.<p>
No parameters, no return.     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="memory.h::memory_suggest_leave_open" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void DLL_SPEC memory_suggest_leave_open </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimize memory device access - request memory device be kept open between calls. 
<p>
By default, the memory device is closed between subsequent calls to read/write. This is to prevent file descriptor leakage by the libsmbios library. At times, however, the overhead of reopening the memory device file on every access is simply too great. This happens, for example, on memory searches, and can add considerable overhead. This function requests that the memory subsystem leave the device open between calls. Must be properly nested with <a class="el" href="memory_8h.html#a4">memory_suggest_close()</a>.<p>
No parameters, no return.     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="memory.h::memory_write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int DLL_SPEC memory_write </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u64&nbsp;</td>
          <td class="mdname" nowrap> <em>offset</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write a buffer to a physical memory address. 
<p>
This function will write a range of bytes to a physical memory address. Note that some OS have severe restrictions on which addresses may be read and written, as well as security restrictions on which security levels are allowed this access. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>buffer</em>&nbsp;</td><td>pointer to buffer containing contents to write </td></tr>
    <tr><td valign=top><em>offset</em>&nbsp;</td><td>starting memory offset </td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>how many bytes of memory to copy </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, &lt; 0 on failure -1 general failure -5 bad memory_access_object (could not instantiate singleton?) -6 bad buffer pointer </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Mar 26 12:27:30 2014 for libsmbios_c library by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
