.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ActiveState::Run 3"
.TH ActiveState::Run 3 "2004-11-26" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
ActiveState::Run \- Collection of small utility functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use ActiveState::Handy qw(run);
\& run("ls -l");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a collection of small utility functions for
running external programs.
.PP
The following functions are provided:
.IP "decode_status( )" 4
.IX Item "decode_status( )"
.PD 0
.ie n .IP "decode_status( $rc )" 4
.el .IP "decode_status( \f(CW$rc\fR )" 4
.IX Item "decode_status( $rc )"
.PD
Will decode the given return code (defaults to $?) and return the 
exit value, the signal it was killed with, and if it dumped core.
.Sp
In scalar context, it will return a string explaining what happened, or 
an empty string if no error occured.
.Sp
.Vb 3
\&  my $foo = `ls`;
\&  my $err = decode_status;
\&  die "ls failed: $err" if $err;
.Ve
.Sp
In array context, it will return a list of key/value pairs containing:
.RS 4
.IP "\s-1WIFEXITED\s0" 4
.IX Item "WIFEXITED"
True when the status code indicates normal termination.
.IP "\s-1WEXITSTATUS\s0" 4
.IX Item "WEXITSTATUS"
If \s-1WIFEXITED\s0, this will contain the low-order 8 bits of the status
value the child passed to exit or returned from main.
.IP "\s-1WIFSIGNALED\s0" 4
.IX Item "WIFSIGNALED"
Non-zero if process was terminated by a signal.
.IP "\s-1WTERMSIG\s0" 4
.IX Item "WTERMSIG"
If \s-1WIFSIGNALED\s0, the terminating signal.
.IP "\s-1WIFSTOPPED\s0" 4
.IX Item "WIFSTOPPED"
Non-zero if the process was stopped.
.IP "\s-1WSTOPSIG\s0" 4
.IX Item "WSTOPSIG"
If \s-1WIFSTOPPED\s0, the signal that stopped the process.
.IP "\s-1WCOREDUMP\s0" 4
.IX Item "WCOREDUMP"
Nonzero if the process dumped core.
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 3
\&  my $foo = `ls`;
\&  my %err = decode_status;
\&  die "ls dumped core" if $err{WCOREDUMP};
.Ve
.RE
.ie n .IP "run( $cmd\fR, \f(CW@args )" 4
.el .IP "run( \f(CW$cmd\fR, \f(CW@args\fR )" 4
.IX Item "run( $cmd, @args )"
Works like the builtin \fIsystem()\fR but will by default print commands to
stdout before it execute them and raise an exception (die) if the
command fails (returns non-zero status).  Like for the command
specifications for \fImake\fR\|(1), you can prefix the command with \*(L"@\*(R" to
suppress the echo and with \*(L"\-\*(R" to suppress the status check.
.Sp
The environment variables \s-1AS_RUN_SILENT\s0 and \s-1AS_RUN_PREFIX\s0 influence
printing as well, see \*(L"\s-1ENVIRONMENT\s0\*(R".
.ie n .IP "shell_quote( @args )" 4
.el .IP "shell_quote( \f(CW@args\fR )" 4
.IX Item "shell_quote( @args )"
Will quote the arguments provided so that they can be passed to the
command shell without interpretation by the shell.  This is useful
with \fIrun()\fR when you can't provide separate \f(CW@args\fR, e.g.:
.Sp
.Vb 1
\&   run(shell_quote("rm", "-f", @files) . " >dev/null");
.Ve
.Sp
In list context it returns the same number of values as arguments
passed in.  Only those arg values that need quoting will be quoted.
.Sp
In scalar context it will return a single string with all the quoted
\&\f(CW@args\fR separated by space.
.Sp
In void context it will attempt inline modification of the \f(CW@args\fR
passed.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
If the \s-1AS_RUN_SILENT\s0 environment variable is \s-1TRUE\s0, then printing of
the command about to run for \fIrun()\fR is suppressed.
.PP
If the \s-1AS_RUN_PREFIX\s0 environment variable is set, then the printed
command is prefixed with the given string.  If \s-1AS_RUN_SILENT\s0 is \s-1TRUE\s0,
then this value is ignored.
.SH "BUGS"
.IX Header "BUGS"
none.
