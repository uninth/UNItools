.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ActiveState::Dir::Atomic 3"
.TH ActiveState::Dir::Atomic 3 "2004-07-15" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
ActiveState::Dir::Atomic \- update directory contents atomically
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use ActiveState::Dir::Atomic;
\&  my $at = ActiveState::Dir::Atomic->new($dirname);
.Ve
.PP
.Vb 5
\&  # Typically, an application for AS::Dir::Atomic is to
\&  # watch for changes to a data directory, and reload a
\&  # set of data files when a change is detected.
\&  my $cur = $at->currentpath;
\&  while (1) {
.Ve
.PP
.Vb 1
\&     # do some work with $cur
.Ve
.PP
.Vb 2
\&     if ($cur ne $at->currentpath) {
\&        $cur = $at->currentpath;
.Ve
.PP
.Vb 1
\&        # reload data files from $cur
.Ve
.PP
.Vb 2
\&     }
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
ActiveState::Dir::Atomic makes it easier to write code that modifies a
directory safely. It does this by enforcing a particular directory structure.
It keeps a configurable number of backup directories, and can be used to
rollback a commit.
.PP
The directory structure is as follows:
.IP "\s-1ROOT/\s0" 4
.IX Item "ROOT/"
The \*(L"root\*(R" of the ActiveState::Dir::Atomic structure.  This is the name of the
directory passed to \fInew()\fR.
.IP "\s-1ROOT/\s0.lock" 4
.IX Item "ROOT/.lock"
The lock file used if the directory is opened for writing.  Not used for
reading.
.IP "\s-1ROOT/1\s0" 4
.IX Item "ROOT/1"
.PD 0
.IP "\s-1ROOT/2\s0" 4
.IX Item "ROOT/2"
.IP "\s-1ROOT/\s0..." 4
.IX Item "ROOT/..."
.PD
The actual directories as exposed to the application.  These directories form
a circular buffer of directories. The active directory cycles through these
numbers over time.  The number of directories is determined by the \f(CW\*(C`rotate\*(C'\fR
parameter to \fInew()\fR; once the directory exists, this parameter is read from the
file \fI\s-1ROOT/\s0.top\fR.
.IP "ROOT/current" 4
.IX Item "ROOT/current"
A symbolic link that points to the currently active subdirectory. When you
\&\fIcommit()\fR, this symbolic link is updated.
.IP "\s-1ROOT/\s0.top" 4
.IX Item "ROOT/.top"
A file containing the number of backups to keep before \fIcommit()\fR overwrites
backups.  When a directory is first created, this number is specified by the
\&\f(CW\*(C`rotate\*(C'\fR parameter.
.PP
This package does \fInot\fR abstract access to the actual directory \*(-- use
standard Perl functions for that. It just ensures that while you modify the
contents of the scratch directory, other applications can safely use the
active directory.
.PP
ActiveState::Dir::Atomic provides the following methods:
.IP "\fInew()\fR" 4
.IX Item "new()"
.Vb 1
\&   $dir = ActiveState::Dir::Atomic($dirname, %opts);
.Ve
.Sp
Creates a new object, opening \f(CW$dirname\fR for reading or writing.  If the
directory is opened for writing it is locked; otherwise no lock is used.  If
the directory cannot be opened or the lock obtained, the constructor will
croak.
.Sp
Options are passed as key/value pairs after the directory name.  The supported
options are:
.RS 4
.IP "writable" 4
.IX Item "writable"
A boolean.  If true, the directory is opened for writing and is locked
exclusively. You can call the \fIscratchdir()\fR, \fIscratchpath()\fR and \fIcommit()\fR
methods.  If not, the directory is opened for reading only, and these methods
will croak if you try to use them.
.IP "create" 4
.IX Item "create"
A boolean.  If true, and writable is also true, the directory is created if it
does not already exist.  Note that the directory will be created when the
object is created, so it will end up existing and empty even if \fIcommit()\fR is
not called.
.IP "timeout" 4
.IX Item "timeout"
A number representing seconds.  Normally ActiveState::Dir::Atomic will wait
forever trying to acquire a lock on the directory if \f(CW\*(C`writable\*(C'\fR is true.  You
can specify how long to wait with this option.  The constructor will croak
if it times out waiting for the lock.
.IP "rotate" 4
.IX Item "rotate"
A number.  If \f(CW\*(C`create\*(C'\fR is true, and the directory did not exist, this is the
number of backups to keep before commits overwrite old directories.  The
default is 4.  If the directory exists, this number is read from a hidden file
that ActiveState::Dir::Atomic saves when it creates directories.
.RE
.RS 4
.RE
.IP "\fIcurrent()\fR" 4
.IX Item "current()"
.Vb 1
\&  my $current = $at->current;
.Ve
.Sp
Returns the index of the current subdirectory. This method consults the
symbolic link each time it is called, to detect changes by other applications.
The index is always an integer greater than 1.
.IP "\fIcurrentpath()\fR" 4
.IX Item "currentpath()"
.Vb 1
\&  my $path = $at->currentpath;
.Ve
.Sp
Returns the full path to the current subdirectory. This method consults the
symbolic link each time it is called, to detect changes by other applications.
.IP "\fIscratch()\fR" 4
.IX Item "scratch()"
.Vb 1
\&  my $scratch = $at->scratch;
.Ve
.Sp
Returns the index of the directory that will become the current directory if
\&\fIcommit()\fR is called. This croaks if the directory was not opened for writing.
.IP "\fIscratchpath()\fR" 4
.IX Item "scratchpath()"
.Vb 1
\&  my $path = $at->scratchpath;
.Ve
.Sp
Returns the full path to the directory that will become the current directory
if \fIcommit()\fR is called. This croaks if the directory was not opened for writing.
.IP "\fIversion()\fR" 4
.IX Item "version()"
.Vb 1
\&  my $version = $at->version;
.Ve
.Sp
Returns the \*(L"version\*(R" of the directory. The version string is an optional
parameter to \fIcommit()\fR, and is intended to provide a more useful string than
the directory index number.
.IP "\fIscan()\fR" 4
.IX Item "scan()"
.Vb 1
\&  my $num = $at->scan(\e&callback);
.Ve
.Sp
Invokes the \f(CW&callback\fR for each subdirectory in the directory, beginning
with the current directory and moving backwards in time.  The callback is
invoked like so:
.Sp
.Vb 1
\&  &callback($fullpath, $index);
.Ve
.Sp
The callback can return false to stop walking.
.Sp
The \f(CW\*(C`scan()\*(C'\fR method normally returns the number of times the callback was
invoked; however, if the callback is not provided, then \f(CW\*(C`scan()\*(C'\fR returns the
number of subdirectories.
.IP "\fIcommit()\fR" 4
.IX Item "commit()"
.Vb 2
\&  $at->commit;
\&  $at->commit($version);
.Ve
.Sp
Updates the \fIROOT/current\fR symbolic link to the next directory. The method
will croak on failure or if the \f(CW\*(C`writable\*(C'\fR option was not passed to the
constructor.
.Sp
Calling \fIcommit()\fR implies \fIclose()\fR. You should not call any other method on the
object after calling \fIcommit()\fR.
.IP "\fIrollback()\fR" 4
.IX Item "rollback()"
.Vb 1
\&  $at->rollback($index);
.Ve
.Sp
Sets the \fIROOT/current\fR symbolic link to the specified index. Subsequent
calls to \fIcommit()\fR will begin overwriting from that index.
.IP "\fIclose()\fR" 4
.IX Item "close()"
Reverts any uncommitted changes and unlocks the directory. You should not call
any other methods after calling \fIclose()\fR.
.Sp
Normally there is no need to call \fIclose()\fR explicitly since the object
destructor will invoke it when the object goes out of scope.
.Sp
This method can not fail and has no return value.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2003, ActiveState Corporation.  All Rights Reserved.
