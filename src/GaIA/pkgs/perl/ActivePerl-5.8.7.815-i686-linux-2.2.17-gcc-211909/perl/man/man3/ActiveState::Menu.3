.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ActiveState::Menu 3"
.TH ActiveState::Menu 3 "2004-11-26" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
ActiveState::Menu \- Present a menu
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use ActiveState::Menu qw(menu prompt yes);
.Ve
.PP
.Vb 1
\& my $sel = menu([qw(Foo Bar Baz)]);
.Ve
.PP
.Vb 14
\& menu(intro  => "M E N U",
\&      menu   => [["&Foo", \e&do_foo],
\&                 ["S&ub", {
\&                     intro      => "S U B  M E N U",
\&                     menu       => [qw(Apples Oranges Exit)],
\&                     loop_until => 2,
\&                 }],
\&                 ["Ba&r", \e&do_bar],
\&                 "-----",
\&                 ["&h", \e&do_help],
\&                 ["(Ba&z)", \e&do_baz]],
\&      prompt => "What (type 'h' for help)?",
\&      force  => 1,
\&     );
.Ve
.PP
.Vb 1
\&  my $ans = (prompt("What is your favourite colour?", "blue"));
.Ve
.PP
.Vb 4
\&  if (yes("Do you really want to quit?")) {
\&      print "Bye\en";
\&      exit;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provide the following functions:
.ie n .IP "menu( %opts )" 4
.el .IP "menu( \f(CW%opts\fR )" 4
.IX Item "menu( %opts )"
This function will present a menu on the terminal.  The return value
is the index of menu item selected (or \f(CW\*(C`undef\*(C'\fR if no item was selected).
.Sp
The following options are recognised:
.Sp
.Vb 6
\&   menu:    something to select from (array ref)
\&   intro:   heading text
\&   prompt:  prompt text
\&   force:   force something to be selected (bool)
\&   disabled_selectable: allow disabled items to be selected
\&   loop_until: show menu in a loop until a particular item is selected
.Ve
.Sp
The items of the \f(CW\*(C`menu\*(C'\fR array can either be plain text strings or an
array reference containing a string and a function reference.
.Sp
If a function is provided, it will be invoked if the item is selected.
The value of \f(CW$_\fR is set to the menu text before the function is called,
so the same function can serve multiple entries and change it
behaviour based on what it finds in \f(CW$_\fR.
.Sp
If the menu text contains the letter \*(L"&\*(R" then the next letter is taken
as a selector.  The menu item can be selected by typing this selector.
The \*(L"&\*(R" character itself is not rendered.
.Sp
If the menu text is enclosed in parenthesis, then that selection is
shown as disabled.  Any action associated with the item is not
triggered if it is selected.
.Sp
If the menu text only consist of the letter \*(L"&\*(R" followed by a
selector char, then the given menu item is invisible, but the
associated action could still be triggered.  This can be used for
hidden commands or help behaviour as demonstrated in the synopsis
above.
.Sp
If the menu text consist of a line of at least 3 dashes, then it is
taken as a separator.  An action is associated with a separator line
is always ignored.
.Sp
If only a single argument is given to the \fImenu()\fR function, it is taken
to be the same as the \f(CW\*(C`menu\*(C'\fR option.
.Sp
The \f(CW\*(C`intro\*(C'\fR text is presented as a heading above the menu.  Simple
markup like *bold*and _underline_ can be used for visual effect.  If
not provided, no heading is used.
.Sp
The \f(CW\*(C`prompt\*(C'\fR option replace the default \*(L"Please select an item?\*(R" text.
.Sp
If the \f(CW\*(C`force\*(C'\fR option has a \s-1TRUE\s0 value then it prevents the \fImenu()\fR
function from returning undef (if the user did not select any item).
It also prevents the index of any disabled items from being returned.
The option \f(CW\*(C`disabled_selectable\*(C'\fR can be used to counter that
behaviour.
.Sp
The loop_until option, if specified, makes the menu run in a loop
until one of the indices specified by the option is selected.  The
value of the option should be either a single index, or a reference
to an array of indices.
.ie n .IP "prompt( $question\fR, \f(CW$default )" 4
.el .IP "prompt( \f(CW$question\fR, \f(CW$default\fR )" 4
.IX Item "prompt( $question, $default )"
This function will ask a question on the terminal and return the
answer given.  If the program is not running on a terminal then the
\&\f(CW$default\fR is returned.
.Sp
This function comes from the \f(CW\*(C`ActiveState::Prompt\*(C'\fR module.  Refer to
the documentation of that module for the complete story.
.ie n .IP "yes( $question\fR, \f(CW$default )" 4
.el .IP "yes( \f(CW$question\fR, \f(CW$default\fR )" 4
.IX Item "yes( $question, $default )"
Will use the prompt function to ask a question and then return a \s-1TRUE\s0
value if the answer was \*(L"yes\*(R".  If no \f(CW$default\fR is given it defaults to
\&\*(L"no\*(R".
.Sp
This function also comes from the \f(CW\*(C`ActiveState::Prompt\*(C'\fR module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
ActiveState::Prompt.
