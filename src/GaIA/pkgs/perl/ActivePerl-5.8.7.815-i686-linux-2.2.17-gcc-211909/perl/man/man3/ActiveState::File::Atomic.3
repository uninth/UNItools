.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Atomic 3"
.TH Atomic 3 "2004-07-15" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
ActiveState::File::Atomic \- edit files atomically with locking
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use ActiveState::File::Atomic;
\&   my $at = ActiveState::File::Atomic->new($filename, writable => 1);
.Ve
.PP
.Vb 3
\&   # For small files:
\&   (my $contents = $at->slurp) =~ s/foo/bar/g;
\&   $at->commit_string($contents);
.Ve
.PP
.Vb 7
\&   # For larger files:
\&   my $wfh = $at->tempfile;
\&   while (defined($_ = $at->readline))) {
\&       s/foo/bar/g;
\&       print $wfh $_;
\&   }
\&   $at->commit_tempfile;
.Ve
.PP
.Vb 2
\&   # If you have your own file:
\&   $at->commit_file($myfile);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
ActiveState::File::Atomic makes it easier to write code that modifies files
safely. It always uses locking, making it safe for concurrent access. It also
handles writing backup files; either simple \*(L".bak\*(R" files, or a configurable
number of numbered backups, inspired by the \fIlogrotate\fR\|(1) utility.
.PP
ActiveState::File::Atomic provides the following methods:
.IP "\fInew()\fR" 4
.IX Item "new()"
.Vb 1
\&    $file = ActiveState::File::Atomic->new($file, %opts);
.Ve
.Sp
Creates a new object, opening the \f(CW$file\fR in either read-only or
read/write mode and locking it.  If the file cannot be opened or the
lock on it cannot be obtained, the constuctor will croak.
.Sp
Options are passed as key/value pairs after the filename.  The
supported options are:
.RS 4
.IP "writable" 4
.IX Item "writable"
A boolean. If true, the file is opened read/write, and you can call the
\&\fIwrite_handle()\fR, \fIrevert()\fR, and \fIcommit()\fR methods. If not, the file is opened
read\-only, and these methods will croak if you try to use them.
.IP "create" 4
.IX Item "create"
A boolean. If true, and writable is also true, the file is created if
it does not already exist.  Note that no guarantees are made about
when the file is created.  It may get created immediately, or it may
only get created when the ActiveState::File::Atomic object is committed.
.IP "mode" 4
.IX Item "mode"
If the create option was used, this option specifies the file
creation mode for the newly created file.
.IP "owner" 4
.IX Item "owner"
If the create option was used, this option specifies the numeric uid
for the newly created file.  Setting this option only makes sense
when running with superuser privileges.
.IP "group" 4
.IX Item "group"
If the create option was used, this option specifies the numeric gid
for the newly created file.  The superuser can specify arbitrary
group IDs, but unprivileged users are normally only allowed to
specify one of the groups they belong to.
.IP "nolock" 4
.IX Item "nolock"
A boolean.  If true, the file is not actually locked until you call the
\&\fIlock()\fR method.  This allows you to minimize the amount of time between
the \fIlock()\fR and the \fIcommit()\fR, if necessary.  Note that you can't actually
call any other methods on the object until you call the \fIlock()\fR method.
.IP "timeout" 4
.IX Item "timeout"
A number representing seconds. Normally ActiveState::File::Atomic will
wait forever trying to acquire a lock on the file. You can specify how
long to wait with this option.  The constructor will croak if it times
out waiting for the lock.
.IP "backup_ext" 4
.IX Item "backup_ext"
A string. If specified, a backup file will be created when you call the
\&\fIcommit()\fR method. The backup file will be named the same thing as the
original file with \f(CW\*(C`backup_ext\*(C'\fR appended.
.IP "rotate" 4
.IX Item "rotate"
A number.  If specified, \f(CW\*(C`rotate\*(C'\fR backups will be kept. The files are
named as the original file with \f(CW\*(C`backup_ext\*(C'\fR and the current rotation
number appended. If you didn't specify \f(CW\*(C`backup_ext\*(C'\fR, the string \f(CW\*(C`.\*(C'\fR
is used. To simply append the rotation number, specify an empty
\&\f(CW\*(C`backup_ext\*(C'\fR. Rotation numbers are always left-padded with zeros if
\&\f(CW\*(C`rotate\*(C'\fR is specified as 10 or greater.  This ensures that the files
sort correctly.
.IP "debug" 4
.IX Item "debug"
A bitmask that can specify one or more internal flags to specify
troubleshooting functionality.  The following bits are currently
supported:
.Sp
.Vb 2
\&    0x0001   strict - recursive lock attempts will produce errors
\&             (additional strictures may be introduced in future)
.Ve
.Sp
.Vb 2
\&    0x0002   trace  - more information will be spit out of stderr
\&             in case of errors or other unusual conditions
.Ve
.Sp
Defaults to \f(CW$ENV\fR{\s-1AS_FILE_ATOMIC_DEBUG\s0} or 0.
.Sp
The 'strict' implementation is currently rather heavy-weight
(it calls \fIfork()\fR).  It may also falsely detect recursive lock
attempts by processes running on different hosts that lock the
same file on a distributed filesystem such as \s-1NFS\s0.
.RE
.RS 4
.RE
.IP "\fIslurp()\fR" 4
.IX Item "slurp()"
Reads the entire contents of the file into a string, and returns it.
.Sp
This method croaks on failure.
.IP "\fIreadline()\fR" 4
.IX Item "readline()"
Returns a single line from the input \f(CW$file\fR, or \f(CW\*(C`undef\*(C'\fR on \s-1EOF\s0. Use this to
iterate through a large file.
.Sp
This method croaks on failure.
.IP "\fIcommit_string()\fR" 4
.IX Item "commit_string()"
.Vb 1
\&   $at->commit_string($contents)
.Ve
.Sp
Commits \f(CW$contents\fR to the file. Internally, this creates a temporary file
and writes \f(CW$contents\fR to it. The temporary file is atomically renamed to the
original file. Backup files are created according to the settings of
\&\f(CW\*(C`backup_ext\*(C'\fR and \f(CW\*(C`rotate\*(C'\fR.  The method will croak on failure or if the
\&\f(CW\*(C`writable\*(C'\fR option was not passed to the constructor.
.Sp
Calling \fIcommit_string()\fR implies \fIclose()\fR. You should not call any other method
on the object after calling \fIcommit_string()\fR.
.IP "\fIcommit_file()\fR" 4
.IX Item "commit_file()"
.Vb 1
\&   $at->commit_file($filename)
.Ve
.Sp
Commits the contents of \f(CW$filename\fR to the file. Internally, this copies the
contents of \f(CW$filename\fR into a temporary file. The temporary file is then
atomically renamed to the original file. Backup files are created according to
the settings of \f(CW\*(C`backup_ext\*(C'\fR and \f(CW\*(C`rotate\*(C'\fR.  The method will croak on failure
or if the \f(CW\*(C`writable\*(C'\fR option was not passed to the constructor.
.Sp
Note that the specified file is only opened, read from, and closed.  It is
neither modified nor deleted by ActiveState::File::Atomic.  The caller is
responsible for cleaning up the file when they no longer need it.
.Sp
Calling \fIcommit_file()\fR implies \fIclose()\fR. You should not call any other method
on the object after calling \fIcommit_file()\fR.
.IP "\fIcommit_fd()\fR" 4
.IX Item "commit_fd()"
.Vb 1
\&   $at->commit_fd(fileno($HANDLE));
.Ve
.Sp
Commits the contents of the file underneath \f(CW$HANDLE\fR to the file.
Internally, this copies from \f(CW$HANDLE\fR to a temporary file. The temporary
file is atomically renamed to the original file. Backup files are created
according to the settings of \f(CW\*(C`backup_ext\*(C'\fR and \f(CW\*(C`rotate\*(C'\fR.  The method will
croak on failure or if the \f(CW\*(C`writable\*(C'\fR option was not passed to the
constructor.
.Sp
Calling \fIcommit_fd()\fR implies \fIclose()\fR. You should not call any other method
on the object after calling \fIcommit_fd()\fR.
.IP "\fItempfile()\fR" 4
.IX Item "tempfile()"
.Vb 1
\&   my $wfh = $at->tempfile;
.Ve
.Sp
Returns a writable handle to a temporary file that will be committed
by \fIcommit_tempfile()\fR.  The returned handle is owned by
ActiveState::File::Atomic and should \s-1NOT\s0 be closed by the caller.
.Sp
This method croaks on failure.
.IP "\fIcommit_tempfile()\fR" 4
.IX Item "commit_tempfile()"
Commits the contents of the temporary file.
.Sp
Calling \fIcommit_tempfile()\fR implies \fIclose()\fR. You should not call any other
method on the object after calling \fIcommit_tempfile()\fR.
.IP "\fIclose()\fR" 4
.IX Item "close()"
Reverts any uncommitted changes and unlocks the file. You should not call any
other methods after calling \fIclose()\fR.
.Sp
Normally there is no need to call \fIclose()\fR explicitly since the object
destructor will invoke it when the object goes out of scope.
.Sp
This method can not fail and has no return value.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2004, ActiveState Corporation.
All Rights Reserved.
