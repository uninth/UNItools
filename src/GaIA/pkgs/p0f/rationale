<p>p0f is a versatile passive OS fingerprinting and masquerade detection
utility, to be used for evidence or information gathering on servers,
firewalls, IDSes, and honeypots, for pen-testing, or just for the fun of
it. It is a complete rewrite of p0f version 1 that used to be maintained
by William Stearns.</p>
<p>Why on a firewall? Well, it is sometimes nice to know the OS of the
other end, without having to nmap it.<br>
It may be started in daemon mode, but is not done so by default.</p>
<p><b>Undocumented applications</b></p>
<b>p0fq - sample p0f query interface</b><pre>
/* 
   p0fq - sample p0f query interface
   ---------------------------------

   Just to show how things should be done, and perhaps to provide
   a truly ineffective way of querying p0f from shell scripts and
   such.

   If you want to query p0f from a production application, just
   implement the same functionality in your code. It's perhaps 10
   lines.

   Copyright (C) 2003-2004 by Michal Zalewski <lcamtuf@coredump.cx>

  */
</pre><b>sendack2 - RST trigger with data payload</b><pre>
/*
   sendack2 - RST trigger with data payload
   ----------------------------------------

   See sendack.c for more information. The only difference is that this
   tool sends a packet with a payload to check for some silly implementations
   that bounce the payload back or do other magic.

   THIS PROGRAM IS NOT SUITABLE FOR GATHERING "Connection refused" SIGNATURES.

   Copyright (C) 2003-2004 by Michal Zalewski <lcamtuf@coredump.cx>

 */
</pre><b>sendack - RST trigger</b><pre>
/*
   sendack - RST trigger
   ---------------------

   This is a trivial code to send a stray ACK packet to a remote
   host. The main purpose of this is to gather new RST ("connection dropped") 
   signatures quickly, but you can also use it for silent active 
   fingerprinting when you can't or don't want to use -A mode.

   THIS PROGRAM IS NOT SUITABLE FOR GATHERING "Connection refused" SIGNATURES.

   Run p0f in the background in -R mode, then run sendack, observe
   results, if any. This code uses a distinct WSS of 12345. If you see
   it in the signature returned by p0f, you need to wildcard the value
   (p0f does the first step for you), as it appears to be dependent on the 
   original packet and may vary on the other party's stack.

   Linux code, may not work on systems that use different mechanism to
   access raw sockets.

   Copyright (C) 2003-2004 by Michal Zalewski <lcamtuf@coredump.cx>

 */
</pre><b>sendsyn - SYN+ACK trigger</b><pre>
/*
   sendsyn - SYN+ACK trigger
   -------------------------

   This is a trivial code to send a SYN packet to a remote host. The main 
   purpose of this is to trigger a clean SYN+ACK or RST+ACK ("connection
   refused") response that can be compared to the signature you've obtained 
   the usual way. By comparing WSS and other parameters, it is possible to 
   determine how much of the signature changes depending on the initial SYN, 
   which is crucial in some cases (see p0fa.fp and p0fr.fp).

   THIS CODE IS NOT SUITABLE FOR GATHERING "Connection dropped" SIGNATURES.

   Run p0f in the background in -A mode (or -R, if you are interested in
   RST+ACK packet), then run sendsyn, observe results, if any. The code uses a 
   distinct WSS of 12345. If you see it in the SYN+ACK (RST+ACK) response, you 
   need to wildcard the WSS value in your new signature (p0f does the
   first step for you).

   Linux code, may not work on systems that use different mechanism to
   access raw sockets.

   Copyright (C) 2003-2004 by Michal Zalewski <lcamtuf@coredump.cx>

 */
</pre><b>tryid</b><pre>
#
# p0f - trivial OS checker
# ------------------------
#
# The least diplomatic way of checking a remote system to
# resolve a signature. Note that the output should be
# taken with a grain of salt (proxies, overzealous
# firewalls, ippersonality, nmap database glitches, etc).
#
</pre>
